[["index.html", "Handout für R Grundkurs URZ und Academic Lab Universität Leipzig Vorwort", " Handout für R Grundkurs URZ und Academic Lab Universität Leipzig Peter Kannewitz peter.kannewitz@uni-leipzig.de Peer Schwertfeger peer.schwertfeger@uni-leipzig.de Stand: 2022-04-25 Vorwort Dieses Handout ist Teil des Grundkurses in R am URZ und am Academic Lab der Uni Leipzig. Besonderem Dank gilt Stephan Poppe und dem Statistik-Team des Instituts für Soziologie für die Unterstützung beim Erstellen der Materialien für diesen Kurs. Hinweis: Dieses Handout ist ständig in Bearbeitung und erhebt keinen Anspruch auf Vollständigkeit. Bitte informiert uns, sollten Angaben nicht mehr aktuell sein bzw. sollten sich Fehler eingeschlichen haben. Vielen Dank! "],["hinweise-zur-verwendung-des-handouts.html", "Hinweise zur Verwendung des Handouts", " Hinweise zur Verwendung des Handouts In den einzelnen Kapiteln wird immer wieder R Code ausgeführt. Dabei wird immer im ersten Block der jeweilige Ausdruck angegeben und im zweiten das dazugehörige Ergebnis, was wie folgt aussieht: 1+1 ## [1] 2 Am Ende eines jeden Kapitels gibt es eine kleine Checkliste, welche als “Prüfe dich selbst” überschrieben ist. Anhand dieser könnt ihr euch testen, ob ihr allem folgen konntet und die Sachverhalte verinnerlicht habt. Wenn nicht, habt ihr dann vielleicht einen Anhaltspunkt, was ihr später vielleicht noch einmal nachlesen könntet. Es empfiehlt sich über die Menüleiste oben die Anzeigeeinstellungen (A) zu ändern. Wenn ihr Mal ein Kapitel durcharbeiten wollt, ist eine Schriftart mit Serifen und ein etwas dunkler Hintergrund vielleicht angenehmer. Also probiert das gerne mal aus! Das gesamte Handout ist über GitHub Pages veröffentlicht. Wenn ihr einen Fehler entdeckt oder Anmerkungen habt, dann zögert nicht ein Issue auf zu machen und Änderungen vorzuschlagen! Über das Auge oben in der Menüleiste kommt ihr zum Repository. "],["einführung.html", "Kapitel 1 Einführung 1.1 Was ist R und warum sollte man R lernen? 1.2 Installation", " Kapitel 1 Einführung Abb. 1.1: R Logo (https://www.r-project.org/logo/) 1.1 Was ist R und warum sollte man R lernen? R ist eine freie Programmiersprache, die in erster Linie für statistische Analysen konzipiert wurde. Durch ihre große Community (siehe Stack Overflow oder RBlogger) und ihre ständige Weiterentwicklung durch sogenannte Packages, ist der Funktionsumfang von R praktisch unbegrenzt. Neben den klassischen Funktionen statistischer Software (Datenaufbereitung, Analysen, Graphikerstellung) sind z.B. folgende Anwendungen möglich: Erstellen von Präsentationen und Papern (mit RMarkdown) Webscraping Qualitative Textanalyse Auslesen von Datenbanken Automatisierungen uvm. Zum Teil durch die vielfältigen Anwendungsmöglichkeiten hat sich bzw. entwickelt sich R zum Goldstandard in der akademischen Welt und in vielen Bereichen der Wirtschaft1. Wie auch bei Sprachen, lernt man Programmiersprachen nicht (nur) durch Kurse. Eine Aktive Auseinandersetzung mit konkreten Problemen hilft, “fließender” im Umgang mit der Sprache zu werden. Kommt man einmal nicht weiter (wird passieren… versprochen!), hilft es, sich solange mit dem Thema zu beschäftigen, bis eine Lösung gefunden wurde. Warum sollte man das auf sich nehmen? 6 Gründe, R zu lernen: Open Source und plattformübergreifend Praktisch unbegrenzter Funktionsumfang Entwickelt sich zum Standard in akademischer Welt und in der Wirtschaft Publizierfähige Graphiken Integration von Aufbereitung, Analyse und Präsentation Internationale Community (Stack Overflow, RBloggers etc.) 1.2 Installation Zunächst muss unser Computer R “lernen”. Um R zu installieren, gehe auf die entsprechende Cran Website. Wähle dein Betriebssystem aus und folge den Anweisungen auf der Website. Um produktiv zu arbeiten, sollte zusätzlich die open source-Vesion von RStudio installiert werden. Weitere Infos hierzu gibt es hier. https://analyticsindiamag.com/has-python-completely-edged-out-r-in-data-science-field/↩︎ "],["oberfläche.html", "Kapitel 2 Oberfläche 2.1 R GUI 2.2 RStudio 2.3 Prüfe dich selbst", " Kapitel 2 Oberfläche 2.1 R GUI Mit der Installation von R wird gleichzeitig ein Graphical User Interface (GUI) mitinstalliert. Hier können wir bereits R Code eingeben und mit Enter an den Computer übergeben. In der nächsten Zeile wird die Antwort vom Computer an uns zurückgegeben. Abb. 2.1: R GUI Diese Oberfläche ist jedoch wenig “komfortabel”. Sie bietet keine zusätzlichen Editoren oder Fenster, um z.B. die gespeicherten Objekte oder Graphiken anzuzeigen. 2.2 RStudio Abb. 2.2: RStudio Logo (https://www.rstudio.com/about/logos/) Abb. 2.3: RStudio Interface RStudio bietet eine nutzer:innenfreundliche (und freie) Alternative für die Nutzung von R. Hier sind zusätzliche Editoren und Übersichten enthalten. Zu nennen ist beispielsweise: Script-Editor Übersicht über Objekte in globaler Umgebung Übersicht über Packages Einfache Dateienhandhabung durch Projects u.v.m. Das Interface von RStudio besteht aus mehreren Fenstern. 2.2.1 Console Abb. 2.4: Console Die R Console dient zur direkten Übergabe von Ausdrücken bzw. Funktionen an R und ist identisch mit der Anzeige in der R GUI. Diese eignet sich für für kleine Tasks bzw. Tests. Das Ergebnis wird direkt unterhalb des Befehls angezeigt. Außerderm werden Ergebnisse aus den Scripten, die keine Graphiken sind, hier angezeigt. Nachdem Code hier eingetippt wurde, wird die Befehlszeile mit der Taste ENTER ausgeführt. 2.2.2 Script Editor Abb. 2.5: Script Editor In der Console kann euer Code langfristig nicht gespeichert werden. Sogenannte R Scripte ermöglichen euch, euren Code zu speichern und nacheinander auszuführen. Der entsprechende Editor muss zunächst händisch geöffnet werden: File \\(\\rightarrow\\) New File \\(\\rightarrow\\) R Script Nachdem Code geschrieben wurde, kann der Code mit folgender Tastenkombination ausgeführt werden: strg + ENTER (Win) bzw. command + ENTER (Mac) Hierzu genügt es, wenn sich der Cursor in einer der Zeilen der Befehlssequenz befindet. Sollen mehrere Befehlssequenzen ausgeführt werden, müssen diese vorher markiert werden. Mit # lassen sich Kommentare in das Script schreiben. Zeilen, in denen dieses Zeichen steht, werden von R ignoriert und nicht ausgeführt. 2.2.3 File-Editor und Environment Abb. 2.6: File-Editor und Environment-Oberfläche Zusätzlich zu der Console und dem Skript-Editor bietet RStudio weitere Fenster, die die Arbeit mit R vereinfachen sollen. Das Fenster unten rechts (Standardeinstellung, Abbildung 2.6a) beinhaltet einen File-Editor (ähnlich zum File Browser (Win) bzw. Finder (Mac)). Hier können Dateien und Verzeichnisstrukturen angesehen und bearbeitet werden (neuer Ordner, Umbenennen von Dateien). Außerdem werden hier Graphiken angezeigt, wenn diese über Code in Scripten oder in der Console erzeugt werden. Des Weiteren gibt es hier eine Übersicht über Packages und das Help Fenster. Oben rechts (Standardeinstellung, Abbildung 2.6b) existiert die Global Environment, in dem alle gespeicherten Objekte angezeigt werden. Schließlich kann man hier auf die History und Verbindungen, wie GitHub, zugegriffen werden. 2.3 Prüfe dich selbst Von dieser Sitzung solltest du folgendes mitgenommen haben: Du solltest die Wesentliche Funktionsweise von R verstanden haben. Du solltest den Aufbau von RStudio kennen. Du solltest wissen, was ein Script ist und wie es geöffnet werden kann. Du solltest wissen, wie Befehlssequenzen in der Console und in einem Script ausgeführt werden. "],["atomare-datentypen.html", "Kapitel 3 Atomare Datentypen 3.1 Arithmetische Grundoperationen und Basisfunktionen 3.2 Erzeugung von referenzierbaren Objekten 3.3 Logische Werte und Operationen 3.4 Zeichenketten (character strings) 3.5 Klasse eines Datenobjektes 3.6 Spezielle Werte 3.7 Prüfe dich selbst", " Kapitel 3 Atomare Datentypen Datentypen sind die Grundlage einer jeder Programmiersprache und somit essenziell zum Verständnis dieser. Sie dienen dazu, verschiedene Typen unterscheiden. Etwa Zahlen von Buchstaben. Das ist besonders wichtig, da wir mit unterschiedlichen ‘Typen’ unterschiedliche Operationen ausführen, bzw. nicht ausführen, können. Zum Beispiel können wir mit Zahlen rechnen, mit Buchstaben hingegen nicht. Mit logischen Bedingungen können wir wiederum Wahrheitswerte ermitteln, mit Zahlen hingegen nicht. Zu wissen, welche Eigenschaften die verschiedene Datentypen haben und welche Operationen mit diesen möglich sind, hilft dabei vielen potenziellen Fehlern vorzubeugen und so Frustration zu vermeiden. Zunächst einmal wollen wir uns die atomaren Datentypen anschauen. Diese bilden die Grundlage aller folgenden Datentypen. Datentyp Beschreibung Beispiel integer ganze Zahlen -2L numeric reelle Zahlen 5.2456 logical logische Werte TRUE character Zeichenfolge “Mexico” NA,NULL,NaN Unbestimmt, Leer, Undefiniert Inf Unendlich Die numerischen Datentypen integer und numeric erlauben es uns numerische Informationen zu repräsentieren. Mit dem Datentyp logical können wir logische Informationen repräsentieren. Um symbolische Informationen zu repräsentieren, verwenden wir den Datentyp character. Mit numerischen-, logischen- und symbolischen Informationen ist es bereits möglich eine Vielzahl von Sachverhalten auszudrücken. Was dies sein kann, wollen wir uns im Folgenden anschauen. 3.1 Arithmetische Grundoperationen und Basisfunktionen R beherscht für alle Zahlen die arithmetischen Grundoperationen und eignet sich somit wunderbar als Taschenrechner. Operation Beschreibung Beispiel +,- Addition, Subtraktion 3-1.2 *,/ Multiplikation, Division 4.8/4 ^ Potenz 5^2 Beispiel: 1+2 ## [1] 3 2*3.5 ## [1] 7 10.1^3 ## [1] 1030.301 R vefügt für den Datentypen numeric über viele elementare Grundfunktionen. Hier nur ein paar wenige relevante Beispiele: Operation Beschreibung Beispiel sqrt() Quadratwurzel sqrt(9) abs() Absolutbetrag abs(-12) log(),exp() Logarithmus und Expontentialfunktion exp(3) round() Runden round(2.12) sqrt(5) ## [1] 2.236068 log(3) ## [1] 1.098612 3.1.1 Funktionsaufrufe Funktionen sind ein wichtiger Teil von R und werden syntaktisch durch eine öffnende und eine schließende Klammer gekennzeichnet, nach diesem Schema: funktion(). Gerade haben wir bereits eine Funktion ausgeführt, indem wir sqrt(9) aufgerufen haben. Ausführlich werden Funktionen noch in Kapitel 5 besprochen. Ein paar Grundlagen wollen wir hier aber schon einmal einführen: Funktionensaufrufe erfolgen in der Regel über das Schema Funktionsname(Argument 1, Argument 2, ...) Beispiel: Die Funktion signif(x,digits) rundet eine Zahl x auf digits signifikante Stellen. Argumente haben zumeist einen festen Namen, sodass diesen eindeutig Werte zugewiesen werden können: signif(x = 12.3456, digits = 3) ## [1] 12.3 Alternativ können aufgrund der Position bzw. der Ordnung den Argumenten Werte zugewiesen werden: signif(12.3456, 3) ## [1] 12.3 3.1.2 Objekte, Funktionen und Referenzen “To understand computations in R, two slogans are helpful: Everything that exists is an object. Everything that happens is a function call.” (John M. Chambers) 2 Funktionen haben wir gerade kennengelernt, also kennen wir auch schon “Everything that happens”. Objekte haben wir auch schon durchgehend verwendet. Geben wir etwa 3 oder \"password\" in die Konsole ein, wird ein entsprechendes Objekt im Speicher erzeugt. Auf diese Objekte haben wir allerdings anschließend keinen Zugriff mehr. Wenn wir jetzt zum Beispiel erneut die Zeichenkette \"password\" benötigten, müssten wir sie auch erneut eintippen. Wie wir dies ändern können, sodass uns Objekte längerfristig zur Verfügung stehen, wollen wir uns jetzt anschauen. 3.2 Erzeugung von referenzierbaren Objekten Mit dem Operator &lt;- lässt sich ein referenzierbares Objekt erstellen. Das bedeutet, dass das Objekt an einen Namen gebunden wird: x_test &lt;- 3 Das Objekt lässt sich nun über den Namen aus dem Speicher abrufen: x_test ## [1] 3 Wenn wir x_test &lt;- 3 ausführen, passiert formal eigentlich Folgendes: Es wird im Speicher ein Objekt mit Wert 3 erzeugt. Es wird der Name x_test an dieses Objekt gebunden, sodass zu diesen Objekt mit dem Namen x_test referiert werden kann bzw. bei Aufruf von x_test der Wert zurückgegeben wird. Über den Namen, welcher nun an das Objekt gebunden ist, können wir dieses jetzt dauerhaft abrufen (referenzieren). 3.2.1 Anmerkung Namen Für Namen dürfen alle Buchstaben und Zahlen verwendet werden, sowie die beiden Sonderzeichen _ und ., wobei diese nicht am Anfang stehen dürfen. Beispiel: x_1 &lt;- 3 Aber: _x_1 &lt;- 3 ## Error: &lt;text&gt;:1:2: unexpected symbol ## 1: _x_1 ## ^ Bemerkung: Man sollte sich bei den Buchstaben nur auf a,…,z bzw. A,.., Z beschränken, auch wenn je nach lokalem Setting z.B. auch andere Buchstaben wie ä zulässig sind. 3.2.2 Rechnungen mit Werten von Objekten Das über seinen Namen referenzierbare Objekt steht für alle weiteren Berechnungen und Operationen zur Verfügung: x_test + 2 ## [1] 5 Das Ergebnis dieses Ausdrucks ist ein neues numerisches Objekt. Dieses kann für spätere Zwecke erneut an einen Namen gebunden werden: y_test &lt;- x_test + 2 y_test ## [1] 5 Unser Speicher sieht aktuell so aus: Zwar haben wir für die Berechnung auch eine Zwei im Speicher angelegt, diese ist aber nicht an einen Namen gebunden. Die Drei und die Fünf hingegen schon. Wenn wir nun x_test und y_test aufrufen, bekommen wir jeweils das entsprechende Objekt zurück. 3.2.3 Namen überschreiben ACHTUNG! - Verwendet man denselben Namen noch einmal, geht die ursprüngliche Referenz verloren: y_test &lt;- log(y_test) Wenn wir jetzt das Objekt zum Namen y_test abfragen, sehen wir Folgendes: y_test ## [1] 1.609438 Das ursprüngliche Objekt zum Namen y_test steht uns nicht mehr zur Verfügung und ist somit unwiederbringlich verloren. Führt man die Codezeile y_test &lt;- log(y_test) jetzt noch einmal aus, so wird y_test wieder an ein anderes Objekt gebunden. Durch dieses Verhalten können wir nie sicher vorhersagen, an welches Objekt y_test momentan gebunden ist. Deswegen sollte man immer neue Namen vergeben und diese nicht doppelt verwenden. 3.2.4 Objekte löschen Wir haben mittlerweile ein paar Objekte im Speicher angelegt und an Namen gebunden. Mit ls() kann man diese abrufen: ls() ## [1] &quot;x_1&quot; &quot;x_test&quot; &quot;y_test&quot; Mit rm() kann man unnötige Objekte über deren Namen entfernen: rm(y_test) Wenn ihr gleich alle angelegte, referenzierbare Objekte aus dem Speicher entfernen wollt: rm(list = ls()) 3.3 Logische Werte und Operationen Die Werte Wahr und Falsch werden in R mit TRUE und FALSE repräsentiert. Es stehen die elementaren Booleschen Operationen zur Verfügung. Operator Bedeutung ! Negation &amp; Und | Oder p &lt;- TRUE !p ## [1] FALSE q &lt;- FALSE (p | q) ## [1] TRUE 3.3.1 Der “logische” Wert NA Neben Wahr und Falsch existiert noch die logische Konstante NA, welche für einen unbestimmten aber bestimmbaren Wert steht (not assigned, not available yet). Dieser Wert wird z. B. universell für alle atomaren Datentypen für die Codierung von Fehlwerten (missings) verwendet. theendoftheworld &lt;- NA 3.3.2 Vergleichs-Operationen Logische Werte spielen in R an verschiedenen Stellen eine große Rolle, da sie z.B. beschreiben, ob bestimmte Vergleiche wahr oder falsch sind. Operator Bedeutung == Gleich? != Ungleich? &gt; / &lt; Größer / Kleiner? &gt;= / &lt;= Größer / Kleiner gleich? alter_tom &lt;- 21 alter_moni &lt;- 24 alter_tom &gt; alter_moni ## [1] FALSE 3.4 Zeichenketten (character strings) Neben Zahlen und logischen Werten, werden wir auch Zeichenketten begegnen bzw. benötigen. Diese können auf zweierlei Art zugewiesen werden: &quot;Tom&quot; ## [1] &quot;Tom&quot; &#39;Moni&#39; ## [1] &quot;Moni&quot; name_bundeskanzler &lt;- &quot;Olaf Scholz&quot; name_bundeskanzler ## [1] &quot;Olaf Scholz&quot; 3.5 Klasse eines Datenobjektes Zur Erinnerung: Datentyp Beschreibung Beispiel integer ganze Zahlen -2L numeric reelle Zahlen 5.2456 logic logische Werte TRUE character Zeichengfolge “Mexico” NULL,Inf,NaN Leer, Unendlich, keine Zahl Die Klasse bzw. der Datentyp eines Objekts lässt sich mit der Funktion class() ermitteln oder aber spezifisch/logisch prüfen. class(alter_moni) ## [1] &quot;numeric&quot; is.numeric(alter_moni) ## [1] TRUE 3.6 Spezielle Werte Die leere Menge wird in R mit dem Wert NULL repräsentiert und dient ganz verschiedenen Zwecken wie z.B. Initialisierung einer Variablen: z &lt;- NULL z ## NULL Division durch 0 ist “erlaubt” und liefert den speziellen Wert Inf zurück. 100/0 ## [1] Inf In R wird ein nicht bestimmbarer Wert (vgl. unbestimmter aber bestimmbarer Wert ‘NA’) durch NaN (not a number) 0/0 3.7 Prüfe dich selbst Von dieser Sitzung solltest du folgendes mitgenommen haben: Du solltest verstanden haben, warum man verschiedene Datentypen unterscheidet. Du solltest die drei grundlegenden weisen Informationen zu repräsentieren nennen können und die dazugehörigen Datentypen. Du solltest verstanden haben, wie man Objekte an einen Namen bindet und warum das nützlich sein kann. Du solltest die elementaren Booleschen (logischen) Operationen in R schreiben können. https://de.wikipedia.org/wiki/R_%28Programmiersprache%29↩︎ "],["strukturierte-datentypen.html", "Kapitel 4 Strukturierte Datentypen 4.1 Vektoren 4.2 Matrizen 4.3 Listen 4.4 Data Frames 4.5 Prüfe dich selbst", " Kapitel 4 Strukturierte Datentypen Basierend auf den einfachen (atomaren) Datentypen existieren in R die folgenden grundlegenden Datenstrukturen. Datenstruktur Beschreibung vector Sequenz gleicher Datentypen matrix Verallg. Vektor in 2 Dimensionen array Verallg. mit Vektor beliebigen Dimensionen list Sequenz ungleicher Datentypen data frame Spezieller Hybrid Liste/Matrix Schema: Dimension Homogen Heterogen 1-Dim. vector list 2-Dim. matrix data frame k-Dim. array Vektoren und Matrizen sind eine strukturierte Zusammenstellung von Daten gleichen Typs. Ein Vektor kann zum Beispiele eine Reihe von integer Werten bündeln, dann aber keine zusätzlichen logischen Werte oder Zeichenketten aufnehmen. Im Gegensatz dazu erlauben Listen und Data Frames es uns auch Daten unterschiedlichen Typs zu bündeln. In diesem Kapitel wollen wir uns damit auseinandersetzen, was für Implikationen die hier skizzierten Eigenschaften der verschiedenen Datenstrukturen auf deren Anwendung haben. Damit die Datenstruktur für euch auch visuell an Gestalt gewinnen, habe ich hier mal eine vereinfachte Darstellung mit den zentralen Eigenschaften der Datenstrukturen gewagt. Sie ist nicht in allen Hinsichten korrekt, soll aber dazu dienen, die grundlegenden Unterschiede der verschiedenen Datenstrukturen zu veranschaulichen. 4.1 Vektoren Vektoren sind sequentiell geordnete Folgen von Werten gleichen Typs. Vektoren können auf ganz unterschiedliche Art erzeugt werden. Beispiel: Informationen zum Lineup für die Clubnacht heute. Mit der Funktion c() (kurz für ‘concatenate’). DJ_Alter &lt;- c(34,45,28,25,20) DJ_Name &lt;- c(&quot;DJ Puma&quot;,&quot;Cabanne&quot;,&quot;Molly&quot;,&quot;Echoton&quot;,&quot;cv313&quot;) DJ_Vinyl &lt;- c(F,T,T,F,F) DJ_Alter ## [1] 34 45 28 25 20 DJ_Name ## [1] &quot;DJ Puma&quot; &quot;Cabanne&quot; &quot;Molly&quot; &quot;Echoton&quot; &quot;cv313&quot; DJ_Vinyl ## [1] FALSE TRUE TRUE FALSE FALSE Anmerkung: Die DJs gibt es wirklich und es lohnt sich mal rein zu hören :). Das Alter und ob die Personen mit Vinyl auflegen oder nicht ist allerdings frei erfunden. Ganz einfach können wir Vektoren auch mit dem Colon-Operator : erzeugen, welcher Zahlenfolgen mit Inkrement 1/-1 generiert. 1:4 ## [1] 1 2 3 4 countdown &lt;- 10:0 countdown ## [1] 10 9 8 7 6 5 4 3 2 1 0 -1.2:5 ## [1] -1.2 -0.2 0.8 1.8 2.8 3.8 4.8 Allgemeinere Folgen kann man mit seq() erzeugen: seq(from = 1, to = 3, by = 0.5 ) ## [1] 1.0 1.5 2.0 2.5 3.0 Auch sehr nützlich: rep(x = c(&quot;Nein!&quot;,&quot;Doch!&quot;), times = 3 ) ## [1] &quot;Nein!&quot; &quot;Doch!&quot; &quot;Nein!&quot; &quot;Doch!&quot; &quot;Nein!&quot; &quot;Doch!&quot; 4.1.1 Abfragen von Werten durch Subsetting von Vektoren Mit dem Operator [] können einzelne Elemente eines Vektors abgefragt werden. Hier zum Beispiel die Indexposition 2: DJ_Alter[2] ## [1] 45 Der Operator ist aber tatsächlich ein “Subset”-Operator und damit wesentlich flexibler und sehr mächtig: DJ_Name[c(1,3)] ## [1] &quot;DJ Puma&quot; &quot;Molly&quot; DJ_Name[-c(1,3)] ## [1] &quot;Cabanne&quot; &quot;Echoton&quot; &quot;cv313&quot; Der Subset-Operator ermöglicht es uns also auch eine Teilmenge des Vektors nach bestimmten Kriterien abzufragen. Hier zum Beispiel die Teilmenge derjenigen Werte, welche einen entsprechenden Index haben. Man sollte [] als einen Operator verstehen, welcher von links auf einen Vektor angewendet wird. Übergibt man [] einen logischen Vektor (passender Länge), so werden alle korrespondierenden “wahren” Elemente eines Vektors ermittelt. Dies ist tatsächlich eine der häufigsten Verwendungen von []: DJ_Name ## [1] &quot;DJ Puma&quot; &quot;Cabanne&quot; &quot;Molly&quot; &quot;Echoton&quot; &quot;cv313&quot; DJ_Vinyl ## [1] FALSE TRUE TRUE FALSE FALSE DJ_Name[DJ_Vinyl] ## [1] &quot;Cabanne&quot; &quot;Molly&quot; 4.1.2 Vektorisierte Operationen Alle atomaren Datentypen sind tatsächlich Vektoren der Länge 1 zahl &lt;- 1 p &lt;- TRUE name &lt;- &quot;Tom&quot; length(zahl) ## [1] 1 length(p) ## [1] 1 length(name) ## [1] 1 Analog agieren dann (fast) alle Operationen, welche für atomare Datentypen definiert sind als vektorisierte Operation, d.h. elementweise: x &lt;- c(1,2,3) y &lt;- c(2,1,3) x + y ## [1] 3 3 6 x + 1 ## [1] 2 3 4 log(x) ## [1] 0.0000000 0.6931472 1.0986123 DJ_Alter &gt; 21 ## [1] TRUE TRUE TRUE TRUE FALSE Der letzte Ausdruck wertet elementweise aus, ob das jeweilige Alter größer als 21 ist und bildet das Ergebnis anschließend auf einen logischen Vektor mit korrespondierender Länge ab. Zur Illustration der folgenden Beispiele brauchen wir noch einen weiteren numerischen Vektor. Da wir jetzt wissen, wie man vektorisierte Operation vollführt, können wir ganz einfach einen Vektor mit den annäherenden Geburtsjahren der Personen aus deren Alter berechnen: DJ_Geburtsjahr &lt;- 2022 - DJ_Alter DJ_Geburtsjahr ## [1] 1988 1977 1994 1997 2002 4.1.3 Operationen auf Vektoren Abhängig vom Datentyp eines Vektors existieren verschiedene Funktionen, welche als Argument einen Vektor nehmen und auf ein Resultat abbilden. Operation Beschreibung length() Länge eines Vektors mean() Durchschnittswert eines num. Vektors max() Maximum eines num. Vektors any() Ist irgendein Wert eines log. Vektors wahr? mean(DJ_Alter) ## [1] 30.4 any(DJ_Vinyl) ## [1] TRUE 4.2 Matrizen Die Datenstruktur einer Matrix verallgemeinert das Konzept eines Vektors in zwei Dimensionen. Eine Matrix kann z. B. durch einen Vektor mit dem Befehl matrix() generiert werden: M &lt;- matrix(data = 1:9, nrow = 3, ncol = 3, byrow = TRUE ) M ## [,1] [,2] [,3] ## [1,] 1 2 3 ## [2,] 4 5 6 ## [3,] 7 8 9 Das Ergebnis gibt uns schon einen Hinweis darauf, wie wir die Matrix “subsetten” können. In den eckigen Klammern ist jeweils der Index vermerkt welche Zeile bzw. Spalte dargestellt wird. Die Indizierung erfolgt dann ähnlich zu Vektoren: M[1,2] ## [1] 2 Lassen wir ein Argument offen und geben zum Beispiel nur einen Zeilenindex an, evaluiert der Ausdruck entsprechend zur gesamten angegebenen Zeile. M[2, ] ## [1] 4 5 6 Analog können wir auch nur das Argument für die Spalte angeben: M[ ,1] ## [1] 1 4 7 4.2.1 Benennung von Spalten Mit der Funktion colnames() lassen sich einerseits die Spalten (columns) einer Matrix benennen/ändern, als auch abrufen. colnames(M) &lt;- c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;) M ## A B C ## [1,] 1 2 3 ## [2,] 4 5 6 ## [3,] 7 8 9 colnames(M) ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; Die Funktion rownames() macht dann gleiches für die Zeilen einer Matrix. Über die Spaltennamen können wir nun auch auf die Elemente der Matrix zugreifen: M[ ,&quot;B&quot;] ## [1] 2 5 8 4.2.2 Erzeugung von Matrizen aus Vektoren Zwei Vektoren können mit der Funktion cbind() in eine Matrix überführt werden. D &lt;- cbind(DJ_Alter,DJ_Geburtsjahr) D ## DJ_Alter DJ_Geburtsjahr ## [1,] 34 1988 ## [2,] 45 1977 ## [3,] 28 1994 ## [4,] 25 1997 ## [5,] 20 2002 Analog können mit rbind() zwei Vektoren als Zeilen zu einer Matrix gebunden werden. Achtung! Achtet darauf, dass die zwei Vektoren den gleichen atomaren Datentypen haben, sonst wird der “höherwertigere” der beiden umgewandelt. Wenn ihr zum Beispiel einen character Vector und einen vom Typ logical mit der Funktion cbind() verbindet, erhaltet ihr eine Matrix mit ausschließlich character Werten. 4.3 Listen Eine Liste ist ein “verallgemeinerter Vektor” und lässt als Elemente beliebige Werte oder Datenstrukturen zu: profil_marie &lt;- list(Name = &quot;Marie&quot;, Freunde = c(&quot;Daphne&quot;,&quot;Peter&quot;), Alter = 24 ) profil_marie ## $Name ## [1] &quot;Marie&quot; ## ## $Freunde ## [1] &quot;Daphne&quot; &quot;Peter&quot; ## ## $Alter ## [1] 24 Die Elemente können auch gleich einem Namen zugeordnet werden. 4.3.1 Indizierung von Listen Die Indizierung von Listen funktioniert etwas anders als bei den homogenen Datenstrukturen, da die Liste eigentlich nur Referenzen auf Objekte sammelt. Wenn wir die einzelnen Objekte für Operationen verwenden wollen, nutzen wir am besten den $ (Dollar) Operator. So können wir die Objekte, auf welche die Liste verweist, direkt ‘ansprechen’. profil_marie$Name ## [1] &quot;Marie&quot; profil_marie$Freunde ## [1] &quot;Daphne&quot; &quot;Peter&quot; Die Verwendung des mittlerweile altbekannten Subset-Operators ist auch möglich. Allerdings müssen wir hier die verschachtelte Struktur der Liste immer mitdenken, was es deutlich komplizierter macht. Hier ein Beispiel: profil_marie[2] ## $Freunde ## [1] &quot;Daphne&quot; &quot;Peter&quot; Mit diesem Aufruf erhalten wir einen Verweis, welcher auf einen Vektor zeigt, welcher die Zeichenketten “Daphne” und “Peter” beinhaltet. profil_marie[[2]][1] ## [1] &quot;Daphne&quot; Diese Funktion evaluiert im ersten Teil profil_marie[[2]] nun tatsächlich zu dem Vektor, auf welchen die Referenz zeigt. Auf diesen wird anschließend nun noch mal der Subset-Operator für die erste Position angewandt (Unser_Vektor[1]). So erhalten wir das erste Element des Vektors. (Was wiederum ein ein-elementiger Vektor ist.) Deutlich einfacher ist hingegen die Indizierung mithilfe des Dollar-Operators und den Namen der Objekte. Damit kommen wir deutlich lesbarer zum selben Ergebnis: profil_marie$Freunde[1] ## [1] &quot;Daphne&quot; Falls ihr noch tiefer in das Subsetting von Listen einsteigen wollt, empfiehlt sich das Kapitel “Subsetting” aus dem Buch Advanced R. 4.4 Data Frames Die für statistische Zwecke häufigste und wichtigste Datenstruktur ist die einer Datentabelle, ein sogenanntes dataframe. Diese können wir ganz einfach aus Vektoren erzeugen: df_lineup &lt;- data.frame(Name = DJ_Name, Alter = DJ_Alter ) df_lineup ## Name Alter ## 1 DJ Puma 34 ## 2 Cabanne 45 ## 3 Molly 28 ## 4 Echoton 25 ## 5 cv313 20 4.4.1 Indizierung von Datentabellen Analog zu Matrizen: df_lineup[3, ] ## Name Alter ## 3 Molly 28 df_lineup[ ,2] ## [1] 34 45 28 25 20 Analog zu Listen können wir die Spalten auch über ihren Namen anwählen. df_lineup$Name ## [1] &quot;DJ Puma&quot; &quot;Cabanne&quot; &quot;Molly&quot; &quot;Echoton&quot; &quot;cv313&quot; 4.4.2 Aufname weiterer Variablen/Spalten Analog zu Matrizen können wir mit der Funktion cbind() Vektoren als Spalten eines bereits bestehenden Data Frames aufnehmen. df_lineup &lt;- cbind(df_lineup,DJ_Vinyl) df_lineup ## Name Alter DJ_Vinyl ## 1 DJ Puma 34 FALSE ## 2 Cabanne 45 TRUE ## 3 Molly 28 TRUE ## 4 Echoton 25 FALSE ## 5 cv313 20 FALSE Alternativ können wir eine Spalte anwählen, welche es noch nicht gibt und anschließend diese an einen Vektor binden. df_lineup$Geburtsjahr &lt;- DJ_Geburtsjahr df_lineup ## Name Alter DJ_Vinyl Geburtsjahr ## 1 DJ Puma 34 FALSE 1988 ## 2 Cabanne 45 TRUE 1977 ## 3 Molly 28 TRUE 1994 ## 4 Echoton 25 FALSE 1997 ## 5 cv313 20 FALSE 2002 4.4.3 Operationen auf Datentabellen Die Objekt, welche in einer Datentabelle gespeichert sind, können wir, wie alle anderen Objekte auch, in Funktionsaufrufen weiter verwenden. mean(df_lineup$Alter) ## [1] 30.4 4.5 Prüfe dich selbst Du solltest die vier grundlegenden strukturierten Datentypen nennen und unterscheiden können. Du solltest wissen, auf welche Weisen du auf die Elemente der unterschiedlichen strukturierten Datentypen zugreifen kannst. Du solltest verstanden haben, welche Möglichkeiten es gibt, verschiedene Teilmengen eines strukturierten Datentyps abzufragen. "],["funktionen.html", "Kapitel 5 Funktionen 5.1 Eigenschaften 5.2 Aufbau 5.3 Verschachtelungen 5.4 Pipes 5.5 Default Werte 5.6 Help Fenster 5.7 Prüfe dich selbst", " Kapitel 5 Funktionen Zur Erinnerung: In R wird grundsätzlich zwischen Funktionen und Objekten unterschieden. In diesem Kapitel wird es um die Grundlagen im Umgang mit Funktionen gehen. Technisch gesehen, handelt es sich bei R um eine funktionale Programmiersprache. D.h., einfach formuliert, dass Problemlösungen durch Funktionen erfolgen.3 5.1 Eigenschaften Die meisten Funktionen in R haben bestimmte eigenschaften: 1. Funktionen sind “eigenständig”. Der Output einer Funktion hängt lediglich von seinem Input ab. Wird eine Funktion mit den gleichen argumentativen Werten zweimal ausgeführt, ist der Output in beiden Durchgängen identisch. Ausnahmen bilden Funktionen, die auf (Pseudo-) Zufallsverfahren beruhen, wie z.B. rnorm(). 2. Funktionen helfen beim Erreichen bestimmter Ziele. Funktionen sollten vom Output her gedacht werden (Welches Ziel soll erreicht werden?). Der Auswahl einer passenden Funktion muss ein Ziel formuliert werden. 3. Funktionen bestehen im Wesentlichen aus einer Komposition von Base-Funktionen. In R sind sogenannte primitive Funktionen definiert und bilden die kleinste Einheit von Funktionen. Beispiel: mean ## function (x, ...) ## UseMethod(&quot;mean&quot;) ## &lt;bytecode: 0x10f176e78&gt; ## &lt;environment: namespace:base&gt; Alle anderen Funktionen bestehen aus einer Komposition dieser primitiven Funktionen. Beispiel: sd ## function (x, na.rm = FALSE) ## sqrt(var(if (is.vector(x) || is.factor(x)) x else as.double(x), ## na.rm = na.rm)) ## &lt;bytecode: 0x10c94d9e0&gt; ## &lt;environment: namespace:stats&gt; 5.2 Aufbau Funktionsaufrufe folgen i.d.R. dem Schema Funktionsname(Argument 1 = ..., Argument 2 = ..., ...) Bei den Argumenten handelt es sich meistens… um ein oder mehrere Objekte, auf die sich die Funktion bezieht. Optionen, die die Verarbeitung des Objekts beeinflusst. Beispiel: rep(x = 1:3, # x ist hier das Objekt times = 2) # times ist die Option Die Reihenfolge der Argumente in einer Funktion sind fest definiert. rep(3, 2) ## [1] 3 3 rep(2, 3) ## [1] 2 2 2 In diesem Fall wird das erste Argument als Objekt (x) und das zweite als Option (times) erkannt. Die Reihenfolge der Argumente ist aber nur dann relevant, wenn die Argumente nicht benannte werden. Werden die Argumente hingegen benannt, wird die interne Reihenfolge überschrieben: rep(x = 2, times = 3) ## [1] 2 2 2 rep(times = 3, x = 2) ## [1] 2 2 2 Wichtiger Hinweis! Es lohnt sich immer, die Argumente in einer Funktion zu benennen. Nicht nur erleichtert es euch, den Code auch nach langer Zeit noch zu verstehen, sondern auch anderen wird das Lesen eures Codes erleichtert. 5.3 Verschachtelungen Bei dem Output von Funktionen handelt es sich (fast) immer um Objekte. Diese Objekte können natürlich direkt wieder einer Funktion übergeben werden. Diese Eigenschaft ermöglicht es, Funktionen zu schachteln. Hieraus ergibt sich, dass R diese Schachtelungen von Innen nach Außen auflöst. Im folgenden Beispiel wird also zunächst der Mittelwert des Vektors bestimmt. Im Anschluss wird der Absolutbetrag hiervon genommen, usw. round(log(abs(mean(c(-1,-2,-3,-4))))) ## [1] 1 Dieses Beispiel ist noch relativ gut überschaubar. Im Arbeiten werden diese Ketten jedoch schnell komplexer und unübersichtlich. Eine Alternative hierzu bieten sogenannte Pipes. 5.4 Pipes Pipes bilden die Alternative zu geschachtelten Funktionen. Erstmals eingeführt wurden diese inner der Package-Familie des Tidyverse (%&gt;%, siehe Kapitel zum Tidyverse). Seit der R Version 4.1.0 ist jedoch auch ein nativer Pipe-Operator verfügbar (|&gt;). Pipes funktionieren analog zu geschachtelten Funktionen: Ein Objekt (X) wird an eine Funktion (z.B. mean()) übergeben. Die Funktion gibt ein Objekt zurück. Das entstandene Objekt wird an eine weitere Funktion übergeben. Auch diese Funktion gibt ein Objekt zurück. usw. Code Beispiel: c(-1,-2,-3,-4) |&gt; mean() |&gt; abs() |&gt; log() |&gt; round() ## [1] 1 An dem Code Beispiel werden die Vorteile von Pipes nochmal deutlich. Die Code-Sequenz kann von Oben nach Unten gelesen werden (wie eine Geschichte). Außerdem wird deutlicher, was mit den Daten Passiert und der Vorgang kann schnell, Durch das Anpassen von Argumenten abgewandelt werden. Pro Tipp Um einen Pipe-Operator einzufügen, kann die Tastenkombination Str + Umschalt + m bzw. CMD + Umschalt + m genutzt werden. Will man statt des nativen Operators den Operator aus dem Tidyverse nutzen, kann das über Tools \\(\\rightarrow\\) Global Options \\(\\rightarrow\\) Code \\(\\rightarrow\\) Use native pipe operator geändert werden. 5.5 Default Werte Die meisten Funktionen in R verfügen über sogenannte Default Werte. Hierbei handelt es sich um voreingestellte Werte, die für bestimmte Argumente verwendet werden, wenn bei diesen kein Wert übergeben wird. Für die Funktion round() ist ein Default Wert von 0 für das Argument digits hinterlegt. Entsprechend sind die folgenden zwei Codezeilen funktional identisch: round(x = pi) ## [1] 3 round(x = pi, digits = 0) ## [1] 3 In manchen Fällen sind aber auch logische Werte als Default Werte hinterlegt. In der Funktion sd() ist das Argument na.rm enthalten. Enthält der Vektor, der der Funktion übergeben wird ein NA, wird die Funktion auch NA zurückgeben. Schließlich ist ein Wert unbekannt und daher kann auch nicht mit Sicherheit eine Standardabweichung bestimmt werden. Mit dem Argument na.rm können vor der Berechnung alle NA entfernt werden. Hier ist ein logischer Default Wert von FALSE vorgegeben. x &lt;- c(1,2,3,NA) sd(x) ## [1] NA # Das entspricht: sd(x, na.rm = FALSE) ## [1] NA # Mit geändertem Wert: sd(x, na.rm = TRUE) ## [1] 1 5.6 Help Fenster Natürlich muss und soll niemand alle Argumente zu allen Funktionen auswendig lernen. R stellt hierzu bereits intern ein hilfreiches Hilfe-Fenster zur Verfügung. Für jede Funktion kann dieses über ?Funktionsaufruf aufgerufen werden. Abb. 5.1: Help Fenster Die Description gibt detailliert Auskunft über die Funktionsweise der Funktion. Hier ist das “Ziel” der Funktion festgeschrieben, dass vor der Auswahl der Funktion von den Nutzer:innen formuliert werden sollte. In der Usage sind die verschiedenen Argumente und ihre interne Reihenfolge (siehe Kapitel 5.2) bereits aufgeführt. Die hier aufgeführten Werte für die Argumente sind die hinterlegten Default Werte. Unter Arguments können die Beschreibungen der einzelnen Argumente gefunden werden. Hier sollte besondern darauf geachtet werden, welcher Datentyp als Wert übergeben werden muss. Details enthält Hinweise zur internen Berechnung von Werten, Verfahren, etc. Das ist dann besonder relevant, wenn es für die Berechnung von Kennwerten keine einheitlichen Konventionen gibt. In der Sektion See also sind Verweise zu anderen Funktionen oder Literaturhinweise vermerkt. Schließlich finden sich im letzten Abschnitt, unter Examples konkrete Code Beispiele für die Anwendung der Funktion. Hinweis! Je nach Package und Entwickler der Funktion ist das korrespondierende Hilfe-Fenster hilfreicher oder weniger hilfreich. Manchmal sind die Beschreibungen sehr kryptisch. Im Zweifel lohnt sich immer eine Google-Suche für euer spezifisches Problem (Stack Overflow!). Und im Zweifel gilt: Immer mit der Ruhe und keine Panik ;-) 5.7 Prüfe dich selbst Von dieser Sitzung solltest du folgendes mitgenommen haben: Du solltest den typischen Aufbau von Funktionen kennen. Du solltest Pipes kennen, verstehen und rudimentär anwenden können. Du solltest wissen, dass es Default Werte gibt und wie du herausfindest, welche Werte als solche hinterlegt sind. Du solltest dich im Hilfefenster zurechtfinden. Für die technischen Details, siehe Wickham, H.: Advanced R, Chapter 6, Introduction.↩︎ "],["packages.html", "Kapitel 6 Packages 6.1 Packages installieren und Laden 6.2 needs()", " Kapitel 6 Packages Alle Probleme und Anwendungen lassen sich, jedenfalls theoretisch, mit den Basis-Funktionen von R realisieren. Um so weiter in der Datenanalyse fortgeschritten wird, desto komplexer werden jedoch die Probleme. Wiederkehrende Probleme lassen sich oft lösen, indem selber Funktionen geschrieben werden. Bei vielen Programmiersprachen kommen hierbei zwei Gedanken auf: (Fast) Alle Probleme waren schonmal da. (Fast) Alle Probleme treten wiederholt auf. Da andere User:innen (wahrscheinlich) bereits auf das gleiche Problem gestoßen sind und entsprechende Funktionen geschrieben haben, um das Problem zu lösen, können diese ihre Funktionen in sogenannten Packages der Allgemeinheit zur Verfügung stellen. So kann mithilfe dieser Packages der Funktionsumfang von R praktisch beliebig erweitert werden. 6.1 Packages installieren und Laden Bevor auf die Funktionen der Packages zurückgegriffen werden kann, muss dieses auf dem Computer installiert werden. Analog könnte man hierunter auch das Lernen von neuen Vokabeln verstehen. Das Installieren erfolgt über die Funktion install.packages(). Das einzige Argument ist der Name des zu ladenden Packages als Character. install.packages(&quot;tidyverse&quot;) Ist das Package installiert, muss es zunächst nun noch geladen werden, bevor es benutzt werden kann. Hierfür gibt es zwei Funktionen: library(tidyverse) require(tidyverse) In der Praxis macht es meist keinen Unterschied, welche Funktion genutzt wird. Das einzige Argument ist der Name des Packages als Name (ohne Anführungszeichen). require() wurde für die Anwendung in Funktionen entwickelt. Wird ein Package hiermit geladen, wird ein FALSE zurückgegeben, wenn das Package nicht installiert ist. require(tidyverse) library() gibt eine Fehlermeldung zurück, wenn das Package nicht installiert ist. Im Alltagsgebrauch wird diese Funktion empfohlen. library(tidyverse) 6.2 needs() Gerade im Arbeitsfluss ist die oben beschriebene Vorgehensweise lästig. Auf dieses Problem sind bereits vorher User:innen gestoßen und haben entsprechend ein Package geschrieben, was den Arbeitsfluss erleichtern soll. Dieses Package heißt (sehr passend) Needs und lädt nur eine Funktionen: needs(). needs() kann, mit Komma getrennt, ein oder mehr Packages als Namen (ohne Anführungszeichen) übergeben werden. Beim Ausführen wird zunächst überprüft, ob das Package installiert ist. Ist es installiert, wird es geladen. Ist es nicht installiert, wird es installiert und anschließend geladen. # install.packages(&quot;needs&quot;) library(needs) needs(haven, tidyverse, lubridate ) Im Arbeitsfluss kann dann ein Package, was benötigt wird, einfach in die Funktion geschrieben und ausgeführt werden. Hinweis! Beim ersten Laden fragt needs, ob es sich selber laden soll, wenn es gebraucht wird. Wählt man yes aus, wird die Zeile library(needs) nicht benötigt. Diese Funktionsweise ist ein wenig “buggy”; heißt: manchmal funktioniert das nicht. Wir empfehlen, einfach das Package zu Beginn zu laden und sich nicht hierauf zu verlassen. "],["dateimanagement.html", "Kapitel 7 Dateimanagement 7.1 Absolute und relative Datenpfade (Exkurs) 7.2 R Projects 7.3 Dateien einlesen", " Kapitel 7 Dateimanagement RStudio bietet intern bereits ein gutes Tool, um Dateien auf der Festplatte zu verarbeiten. Dateien lassen sich hier löschen, umbenennen, neuen Ordnern hinzufügen, verschieben oder kopieren. 7.1 Absolute und relative Datenpfade (Exkurs) Um Dateien in R zu laden, muss zumeist ein Datenpfad angegeben werden, der zu der zu ladenden Datei führt. Der Datenpfad ist dabei zunächst entsprechen lang: df_example &lt;- read.csv(file = &quot;/Users/username/Documents/GitHub/r-kurs/sitzung/data/strata.csv&quot;) Diese langen Datenpfade können mithilfe von Working Directories (WD) gelöst werden. Diese können mit der Funktion setwd() eingerichtet werden. setwd(dir = &quot;/Users/username/Documents/GitHub/r-kurs/sitzung&quot;) Im Zweifel kann die WD dann mithilfe von getwd() abgerufen werden. Wurde eine WD festgelegt, kann der Datenpfad nun bei dem Ort beginnen, der über die setwd() Funktion festgelegt wurde. df_example &lt;- read.csv(file = &quot;data/strata.csv&quot;) Der Nachteil dieser Herangehensweise ist, dass die WD global für alle Arbeitsschritte festgelegt wird. Sollen aber WDs für einzelne “Projekte” festgelegt werden, sollten RProjects genutzt werden. 7.2 R Projects Um ein R Project anzulegen, sollten folgende Schritte befolgt werden: Projekt-Ordner anlegen (Name des Ordners wird zum Projekt-Namen) In RStudio über Projects (oben rechts) New Project... wählen New Project \\(\\Rightarrow\\) Existing Directory \\(\\Rightarrow\\) Erstellten Ordner aus 1. wählen \\(\\Rightarrow\\) Create Ein Projekt kann dann immer über die .RProj-Datei geöffnet werden. Vorteile von Projekten: Wechsel von Projekten einfach möglich (WD muss nicht immer neu festgelegt werden) Code wird transportabel Deutlich übersichtlicher als lose Ordnerstruktur RHistory wird projektbezogen gespeichert 7.3 Dateien einlesen In R sind grundsätzlich alle Datei-Typen einlesbar bzw. verarbeitbar. Hierunter zählen z.B. Datenformat File-Extension Bemerkung RData/RDS .Rda bzw. .Rds native R-Datenformate CSV .csv Comma-Seperated Values Text/ASCII .txt Reines Textfile XLS .xls bzw. .xlsx EXCEL-Datenformat SAV .sav SPSS-Datenformat DTA .dta Stata-Datenformat R .R Speicherung als R-Skript R interne Dateien, sowie verschiedene Text-Formate (.csv, .tsv, .txt, …) können bereits mit R Base eingelesen werden. Komplexere Datenformate (Excel, Stata, SPSS) benötigen bestimmte Packages. 7.3.1 R interne Dateien "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
