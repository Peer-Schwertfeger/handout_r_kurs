[["index.html", "Handout für R Grundkurs URZ und Academic Lab Universität Leipzig Vorwort", " Handout für R Grundkurs URZ und Academic Lab Universität Leipzig Peter Kannewitz peter.kannewitz@uni-leipzig.de Peer Schwertfeger peer.schwertfeger@uni-leipzig.de Stand: 2022-04-07 Vorwort Dieses Handout ist Teil des Grundkurses in R am URZ und am Academic Lab der Uni Leipzig. Besonderem Dank gilt Stephan Poppe und dem Statistik-Team des Instituts für Soziologie für die Unterstützung beim Erstellen der Materialien für diesen Kurs. Hinweis: Dieses Handout ist ständig in Bearbeitung und erhebt keinen Anspruch auf Vollständigkeit. Bitte informiert uns, sollten Angaben nicht mehr aktuell sein bzw. sollten sich Fehler eingeschlichen haben. Vielen Dank! "],["hinweise-zur-verwendung-des-handouts.html", "Hinweise zur Verwendung des Handouts", " Hinweise zur Verwendung des Handouts In den einzelnen Kapiteln wird immer wieder R Code ausgeführt. Dabei wird immer im ersten Block der jeweilige Ausdruck angegeben und im zweiten das dazugehörige Ergebnis, was wie folgt aussieht: 1+1 ## [1] 2 Am Ende eines jeden Kapitels gibt es eine kleine Checkliste, welche als “Prüfe dich selbst” überschrieben ist. Anhand dieser könnt ihr euch testen, ob ihr allem folgen konntet und die Sachverhalte verinnerlicht habt. Wenn nicht, habt ihr dann vielleicht einen Anhaltspunkt, was ihr später vielleicht noch einmal nachlesen könntet. Es empfiehlt sich über die Menüleiste oben die Anzeigeeinstellungen (A) zu ändern. Wenn ihr Mal ein Kapitel durcharbeiten wollt, ist eine Schriftart mit Serifen und ein etwas dunkler Hintergrund vielleicht angenehmer. Also probiert das gerne mal aus! Das gesamte Handout ist über GitHub Pages veröffentlicht. Wenn ihr einen Fehler entdeckt oder Anmerkungen habt, dann zögert nicht ein Issue auf zu machen und Änderungen vorzuschlagen! Über das Auge oben in der Menüleiste kommt ihr zum Repository. "],["einführung.html", "Kapitel 1 Einführung 1.1 Was ist R und warum sollte man R lernen? 1.2 Installation", " Kapitel 1 Einführung Abb. 1.1: R Logo (https://www.r-project.org/logo/) 1.1 Was ist R und warum sollte man R lernen? R ist eine freie Programmiersprache, die in erster Linie für statistische Analysen konzipiert wurde. Durch ihre große Community (siehe Stack Overflow oder RBlogger) und ihre ständige Weiterentwicklung durch sogenannte Packages, ist der Funktionsumfang von R praktisch unbegrenzt. Neben den klassischen Funktionen statistischer Software (Datenaufbereitung, Analysen, Graphikerstellung) sind z.B. folgende Anwendungen möglich: Erstellen von Präsentationen und Papern (mit RMarkdown) Webscraping Qualitative Textanalyse Auslesen von Datenbanken Automatisierungen uvm. Zum Teil durch die vielfältigen Anwendungsmöglichkeiten hat sich bzw. entwickelt sich R zum Goldstandard in der akademischen Welt und in vielen Bereichen der Wirtschaft1. Wie auch bei Sprachen, lernt man Programmiersprachen nicht (nur) durch Kurse. Eine Aktive Auseinandersetzung mit konkreten Problemen hilft, “fließender” im Umgang mit der Sprache zu werden. Kommt man einmal nicht weiter (wird passieren… versprochen!), hilft es, sich solange mit dem Thema zu beschäftigen, bis eine Lösung gefunden wurde. Warum sollte man das auf sich nehmen? 6 Gründe, R zu lernen: Open Source und plattformübergreifend Praktisch unbegrenzter Funktionsumfang Entwickelt sich zum Standard in akademischer Welt und in der Wirtschaft Publizierfähige Graphiken Integration von Aufbereitung, Analyse und Präsentation Internationale Community (Stack Overflow, RBloggers etc.) 1.2 Installation Zunächst muss unser Computer R “lernen”. Um R zu installieren, gehe auf die entsprechende Cran Website. Wähle dein Betriebssystem aus und folge den Anweisungen auf der Website. Um produktiv zu arbeiten, sollte zusätzlich die open source-Vesion von RStudio installiert werden. Weitere Infos hierzu gibt es hier. https://analyticsindiamag.com/has-python-completely-edged-out-r-in-data-science-field/↩︎ "],["oberfläche.html", "Kapitel 2 Oberfläche 2.1 R GUI 2.2 RStudio 2.3 Prüfe dich selbst", " Kapitel 2 Oberfläche 2.1 R GUI Mit der Installation von R wird gleichzeitig ein Graphical User Interface (GUI) mitinstalliert. Hier können wir bereits R Code eingeben und mit Enter an den Computer übergeben. In der nächsten Zeile wird die Antwort vom Computer an uns zurückgegeben. Abb. 2.1: R GUI Diese Oberfläche ist jedoch wenig “komfortabel”. Sie bietet keine zusätzlichen Editoren oder Fenster, um z.B. die gespeicherten Objekte oder Graphiken anzuzeigen. 2.2 RStudio Abb. 2.2: RStudio Logo (https://www.rstudio.com/about/logos/) Abb. 2.3: RStudio Interface RStudio bietet eine nutzer:innenfreundliche (und freie) Alternative für die Nutzung von R. Hier sind zusätzliche Editoren und Übersichten enthalten. Zu nennen ist beispielsweise: Script-Editor Übersicht über Objekte in globaler Umgebung Übersicht über Packages Einfache Dateienhandhabung durch Projects u.v.m. Das Interface von RStudio besteht aus mehreren Fenstern. 2.2.1 Console Abb. 2.4: Console Die R Console dient zur direkten Übergabe von Ausdrücken bzw. Funktionen an R und ist identisch mit der Anzeige in der R GUI. Diese eignet sich für für kleine Tasks bzw. Tests. Das Ergebnis wird direkt unterhalb des Befehls angezeigt. Außerderm werden Ergebnisse aus den Scripten, die keine Graphiken sind, hier angezeigt. Nachdem Code hier eingetippt wurde, wird die Befehlszeile mit der Taste ENTER ausgeführt. 2.2.2 Script Editor In der Console kann euer Code langfristig nicht gespeichert werden. Sogenannte R Scripte ermöglichen euch, euren Code zu speichern und nacheinander auszuführen. Der entsprechende Editor muss zunächst händisch geöffnet werden: File \\(\\rightarrow\\) New File \\(\\rightarrow\\) R Script Nachdem Code geschrieben wurde, kann der Code mit folgender Tastenkombination ausgeführt werden: strg + ENTER (Win) bzw. command + ENTER (Mac) Hierzu genügt es, wenn sich der Cursor in einer der Zeilen der Befehlssequenz befindet. Sollen mehrere Befehlssequenzen ausgeführt werden, müssen diese vorher markiert werden. Mit # lassen sich Kommentare in das Script schreiben. Zeilen, in denen dieses Zeichen steht, werden von R ignoriert und nicht ausgeführt. 2.2.3 File-Editor und Environment Abb. 2.5: File-Editor und Environment-Oberfläche Zusätzlich zu der Console und dem Skript-Editor bietet RStudio weitere Fenster, die die Arbeit mit R vereinfachen sollen. Das Fenster unten rechts (Standardeinstellung, Abbildung 2.5a) beinhaltet einen File-Editor (ähnlich zum File Browser (Win) bzw. Finder (Mac)). Hier können Dateien und Verzeichnisstrukturen angesehen und bearbeitet werden (neuer Ordner, Umbenennen von Dateien). Außerdem werden hier Graphiken angezeigt, wenn diese über Code in Scripten oder in der Console erzeugt werden. Des Weiteren gibt es hier eine Übersicht über Packages und das Help Fenster. Oben rechts (Standardeinstellung, Abbildung 2.5b) existiert die Global Environment, in dem alle gespeicherten Objekte angezeigt werden. Schließlich kann man hier auf die History und Verbindungen, wie GitHub, zugegriffen werden. 2.3 Prüfe dich selbst Von dieser Sitzung solltest du folgendes mitgenommen haben: Du solltest die Wesentliche Funktionsweise von R verstanden haben. Du solltest den Aufbau von RStudio kennen. Du solltest wissen, was ein Script ist und wie es geöffnet werden kann. Du solltest wissen, wie Befehlssequenzen in der Console und in einem Script ausgeführt werden. "],["atomare-datentypen.html", "Kapitel 3 Atomare Datentypen 3.1 Arithmetische Grundoperationen und Basisfunktionen 3.2 Erzeugung von referenzierbaren Objekten 3.3 Logische Werte und Operationen 3.4 Zeichenketten (character strings) 3.5 Klasse eines Datenobjektes 3.6 Spezielle Werte 3.7 Prüfe dich selbst", " Kapitel 3 Atomare Datentypen Datentypen sind die Grundlage einer jeder Programmiersprache und somit essenziell zum Verständnis dieser. Sie dienen dazu, verschiedene Typen unterscheiden. Etwa Zahlen von Buchstaben. Das ist besonders wichtig, da wir mit unterschiedlichen ‘Typen’ unterschiedliche Operationen ausführen, bzw. nicht ausführen, können. Zum Beispiel können wir mit Zahlen rechnen, mit Buchstaben hingegen nicht. Mit logischen Bedingungen können wir wiederum Wahrheitswerte ermitteln, mit Zahlen hingegen nicht. Zu wissen, welche Eigenschaften die verschiedene Datentypen haben und welche Operationen mit diesen möglich sind, hilft dabei vielen potenziellen Fehlern vorzubeugen und so Frustration zu vermeiden. Zunächst einmal wollen wir uns die atomaren Datentypen anschauen. Diese bilden die Grundlage aller folgenden Datentypen. Datentyp Beschreibung Beispiel integer ganze Zahlen -2L numeric reelle Zahlen 5.2456 logic logische Werte TRUE character Zeichenfolge “Mexico” NA,NULL,NaN Unbestimmt, Leer, Undefiniert Inf Unendlich Die numerischen Datentypen integer und numeric erlauben es uns numerische Informationen zu repräsentieren. Mit dem Datentyp logic können wir logische Informationen repräsentieren. Um symbolische Informationen zu repräsentieren, verwenden wir den Datentyp character. Mit numerischen-, logischen- und symbolischen Informationen ist es bereits möglich eine Vielzahl von Sachverhalten auszudrücken. Was dies sein kann, wollen wir uns im Folgenden anschauen. 3.1 Arithmetische Grundoperationen und Basisfunktionen R beherscht für alle Zahlen die arithmetischen Grundoperationen und eignet sich somit wunderbar als Taschenrechner. Operation Beschreibung Beispiel +,- Addition, Subtraktion 3-1.2 *,/ Multiplikation, Division 4.8/4 ^ Potenz 5^2 Beispiel: 1+2 ## [1] 3 2*3.5 ## [1] 7 10.1^3 ## [1] 1030.301 R vefügt für den Datentypen numeric über viele elementare Grundfunktionen. Hier nur ein paar wenige relevante Beispiele: Operation Beschreibung Beispiel sqrt() Quadratwurzel sqrt(9) abs() Absolutbetrag abs(-12) log(),exp() Logarithmus und Expontentialfunktion exp(3) round() Runden round(2.12) sqrt(5) ## [1] 2.236068 log(3) ## [1] 1.098612 3.1.1 Funktionsaufrufe Funktionen sind ein wichtiger Teil von R und werden syntaktisch durch eine öffnende und eine schließende Klammer gekennzeichnet, nach diesem Schema: funktion(). Gerade haben wir bereits eine Funktion ausgeführt, indem wir sqrt(9) aufgerufen haben. Ausführlich werden Funktionen noch in Kapitel 5 besprochen. Ein paar Grundlagen wollen wir hier aber schon einmal einführen: Funktionensaufrufe erfolgen in der Regel über das Schema Funktionsname(Argument 1, Argument 2, ...) Beispiel: Die Funktion signif(x,digits) rundet eine Zahl x auf digits signifikante Stellen. Argumente haben zumeist einen festen Namen, sodass diesen eindeutig Werte zugewiesen werden können: signif(x = 12.3456, digits = 3) ## [1] 12.3 Alternativ können aufgrund der Position bzw. der Ordnung den Argumenten Werte zugewiesen werden: signif(12.3456, 3) ## [1] 12.3 3.1.2 Objekte, Funktionen und Referenzen “To understand computations in R, two slogans are helpful: Everything that exists is an object. Everything that happens is a function call.” (John M. Chambers) 2 Funktionen haben wir gerade kennengelernt, also kennen wir auch schon “Everything that happens”. Objekte haben wir auch schon durchgehend verwendet. Geben wir etwa 3 oder \"password\" in die Konsole ein, wird ein entsprechendes Objekt im Speicher erzeugt. Auf diese Objekte haben wir allerdings anschließend keinen Zugriff mehr. Wenn wir jetzt zum Beispiel erneut die Zeichenkette \"password\" benötigten, müssten wir sie auch erneut eintippen. Wie wir dies ändern können, sodass uns Objekte längerfristig zur Verfügung stehen, wollen wir uns jetzt anschauen. 3.2 Erzeugung von referenzierbaren Objekten Mit dem Operator &lt;- lässt sich ein referenzierbares Objekt erstellen. Das bedeutet, dass das Objekt an einen Namen gebunden wird: x_test &lt;- 3 Das Objekt lässt sich nun über den Namen aus dem Speicher abrufen: x_test ## [1] 3 Wenn wir x_test &lt;- 3 ausführen, passiert formal eigentlich Folgendes: Es wird im Speicher ein Objekt mit Wert 3 erzeugt. Es wird der Name x_test an dieses Objekt gebunden, sodass zu diesen Objekt mit dem Namen x_test referiert werden kann bzw. bei Aufruf von x_test der Wert zurückgegeben wird. Über den Namen, welcher nun an das Objekt gebunden ist, können wir dieses jetzt dauerhaft abrufen (referenzieren). 3.2.1 Anmerkung Namen Für Namen dürfen alle Buchstaben und Zahlen verwendet werden, sowie die beiden Sonderzeichen _ und ., wobei diese nicht am Anfang stehen dürfen. Beispiel: x_1 &lt;- 3 Aber: _x_1 &lt;- 3 ## Error: &lt;text&gt;:1:1: unexpected input ## 1: _ ## ^ Bemerkung: Man sollte sich bei den Buchstaben nur auf a,…,z bzw. A,.., Z beschränken, auch wenn je nach lokalem Setting z.B. auch andere Buchstaben wie ä zulässig sind. 3.2.2 Rechnungen mit Werten von Objekten Das über seinen Namen referenzierbare Objekt steht für alle weiteren Berechnungen und Operationen zur Verfügung: x_test + 2 ## [1] 5 Das Ergebnis dieses Ausdrucks ist ein neues numerisches Objekt. Dieses kann für spätere Zwecke erneut an einen Namen gebunden werden: y_test &lt;- x_test + 2 y_test ## [1] 5 Unser Speicher sieht aktuell so aus: Zwar haben wir für die Berechnung auch eine Zwei im Speicher angelegt, diese ist aber nicht an einen Namen gebunden. Die Drei und die Fünf hingegen schon. Wenn wir nun x_test und y_test aufrufen, bekommen wir jeweils das entsprechende Objekt zurück. 3.2.3 Namen überschreiben ACHTUNG! - Verwendet man denselben Namen noch einmal, geht die ursprüngliche Referenz verloren: y_test &lt;- log(y_test) Wenn wir jetzt das Objekt zum Namen y_test abfragen, sehen wir Folgendes: y_test ## [1] 1.609438 Das ursprüngliche Objekt zum Namen y_test steht uns nicht mehr zur Verfügung und ist somit unwiederbringlich verloren. Führt man die Codezeile y_test &lt;- log(y_test) jetzt noch einmal aus, so wird y_test wieder an ein anderes Objekt gebunden. Durch dieses Verhalten können wir nie sicher vorhersagen, an welches Objekt y_test momentan gebunden ist. Deswegen sollte man immer neue Namen vergeben und diese nicht doppelt verwenden. 3.2.4 Objekte löschen Wir haben mittlerweile ein paar Objekte im Speicher angelegt und an Namen gebunden. Mit ls() kann man diese abrufen: ls() ## [1] &quot;alter_moni&quot; &quot;alter_tom&quot; &quot;countdown&quot; &quot;D&quot; &quot;df_lineup&quot; ## [6] &quot;DJ_Alter&quot; &quot;DJ_Geburtsjahr&quot; &quot;DJ_Name&quot; &quot;DJ_Vinyl&quot; &quot;M&quot; ## [11] &quot;name&quot; &quot;name_bundeskanzler&quot; &quot;p&quot; &quot;profil_marie&quot; &quot;q&quot; ## [16] &quot;theendoftheworld&quot; &quot;x&quot; &quot;x_1&quot; &quot;x_test&quot; &quot;y&quot; ## [21] &quot;y_test&quot; &quot;z&quot; &quot;zahl&quot; Mit rm() kann man unnötige Objekte über deren Namen entfernen: rm(y_test) Wenn ihr gleich alle angelegte, referenzierbare Objekte aus dem Speicher entfernen wollt: rm(list = ls()) 3.3 Logische Werte und Operationen Die Werte Wahr und Falsch werden in R mit TRUE und FALSE repräsentiert. Es stehen die elementaren Booleschen Operationen zur Verfügung. Operator Bedeutung ! Negation &amp; Und | Oder p &lt;- TRUE !p ## [1] FALSE q &lt;- FALSE (p | q) ## [1] TRUE 3.3.1 Der “logische” Wert NA Neben Wahr und Falsch existiert noch die logische Konstante NA, welche für einen unbestimmten aber bestimmbaren Wert steht (not assigned, not available yet). Dieser Wert wird z. B. universell für alle atomaren Datentypen für die Codierung von Fehlwerten (missings) verwendet. theendoftheworld &lt;- NA 3.3.2 Vergleichs-Operationen Logische Werte spielen in R an verschiedenen Stellen eine große Rolle, da sie z.B. beschreiben, ob bestimmte Vergleiche wahr oder falsch sind. Operator Bedeutung == Gleich? != Ungleich? &gt; / &lt; Größer / Kleiner? &gt;= / &lt;= Größer / Kleiner gleich? alter_tom &lt;- 21 alter_moni &lt;- 24 alter_tom &gt; alter_moni ## [1] FALSE 3.4 Zeichenketten (character strings) Neben Zahlen und logischen Werten, werden wir auch Zeichenketten begegnen bzw. benötigen. Diese können auf zweierlei Art zugewiesen werden: &quot;Tom&quot; ## [1] &quot;Tom&quot; &#39;Moni&#39; ## [1] &quot;Moni&quot; name_bundeskanzler &lt;- &quot;Olaf Scholz&quot; name_bundeskanzler ## [1] &quot;Olaf Scholz&quot; 3.5 Klasse eines Datenobjektes Zur Erinnerung: Datentyp Beschreibung Beispiel integer ganze Zahlen -2L numeric reelle Zahlen 5.2456 logic logische Werte TRUE character Zeichengfolge “Mexico” NULL,Inf,NaN Leer, Unendlich, keine Zahl Die Klasse bzw. der Datentyp eines Objekts lässt sich mit der Funktion class() ermitteln oder aber spezifisch/logisch prüfen. class(alter_moni) ## [1] &quot;numeric&quot; is.numeric(alter_moni) ## [1] TRUE 3.6 Spezielle Werte Die leere Menge wird in R mit dem Wert NULL repräsentiert und dient ganz verschiedenen Zwecken wie z.B. Initialisierung einer Variablen: z &lt;- NULL z ## NULL Division durch 0 ist “erlaubt” und liefert den speziellen Wert Inf zurück. 100/0 ## [1] Inf In R wird ein nicht bestimmbarer Wert (vgl. unbestimmter aber bestimmbarer Wert ‘NA’) durch NaN (not a number) 0/0 3.7 Prüfe dich selbst Von dieser Sitzung solltest du folgendes mitgenommen haben: Du solltest verstanden haben, warum man verschiedene Datentypen unterscheidet. Du solltest die drei grundlegenden weisen Informationen zu repräsentieren nennen können und die dazugehörigen Datentypen. Du solltest verstanden haben, wie man Objekte an einen Namen bindet und warum das nützlich sein kann. Du solltest die elementaren Booleschen (logischen) Operationen in R schreiben können. https://de.wikipedia.org/wiki/R_%28Programmiersprache%29↩︎ "],["strukturierte-datentypen.html", "Kapitel 4 Strukturierte Datentypen 4.1 Vektoren 4.2 Matrizen 4.3 Listen 4.4 Data Frames 4.5 Prüfe dich selbst", " Kapitel 4 Strukturierte Datentypen Basierend auf den einfachen (atomaren) Datentypen existieren in R die folgenden grundlegenden Datenstrukturen. Datenstruktur Beschreibung vector Sequenz gleicher Datentypen matrix Verallg. Vektor in 2 Dimensionen array Verallg. mit Vektor beliebigen Dimensionen list Sequenz ungleicher Datentypen data frame Spezieller Hybrid Liste/Matrix Schema: Dimension Homogen Heterogen 1-Dim. vector list 2-Dim. matrix data frame k-Dim. array Vektoren und Matrizen sind eine strukturierte Zusammenstellung von Daten gleichen Typs. Ein Vektor kann zum Beispiele eine Reihe von integer Werten bündeln, dann aber keine zusätzlichen logischen Werte oder Zeichenketten aufnehmen. Im Gegensatz dazu erlauben Listen und Data Frames es uns auch Daten unterschiedlichen Typs zu bündeln. In diesem Kapitel wollen wir uns damit auseinandersetzen, was für Implikationen die hier skizzierten Eigenschaften der verschiedenen Datenstrukturen auf deren Anwendung haben. Damit die Datenstruktur für euch auch visuell an Gestalt gewinnen, habe ich hier mal eine vereinfachte Darstellung mit den zentralen Eigenschaften der Datenstrukturen gewagt. Sie ist nicht in allen Hinsichten korrekt, soll aber dazu dienen, die grundlegenden Unterschiede der verschiedenen Datenstrukturen zu veranschaulichen. 4.1 Vektoren Vektoren sind sequentiell geordnete Folgen von Werten gleichen Typs. Vektoren können auf ganz unterschiedliche Art erzeugt werden. Beispiel: Informationen zum Lineup für die Clubnacht heute. Mit der Funktion c() (kurz für ‘concatenate’). DJ_Alter &lt;- c(34,45,28,25,20) DJ_Name &lt;- c(&quot;DJ Puma&quot;,&quot;Cabanne&quot;,&quot;Molly&quot;,&quot;Echoton&quot;,&quot;cv313&quot;) DJ_Vinyl &lt;- c(F,T,T,F,F) DJ_Alter ## [1] 34 45 28 25 20 DJ_Name ## [1] &quot;DJ Puma&quot; &quot;Cabanne&quot; &quot;Molly&quot; &quot;Echoton&quot; &quot;cv313&quot; DJ_Vinyl ## [1] FALSE TRUE TRUE FALSE FALSE Anmerkung: Die DJs gibt es wirklich und es lohnt sich mal rein zu hören :). Das Alter und ob die Personen mit Vinyl auflegen oder nicht ist allerdings frei erfunden. Ganz einfach können wir Vektoren auch mit dem Colon-Operator : erzeugen, welcher Zahlenfolgen mit Inkrement 1/-1 generiert. 1:4 ## [1] 1 2 3 4 countdown &lt;- 10:0 countdown ## [1] 10 9 8 7 6 5 4 3 2 1 0 -1.2:5 ## [1] -1.2 -0.2 0.8 1.8 2.8 3.8 4.8 Allgemeinere Folgen kann man mit seq() erzeugen: seq(from = 1, to = 3, by = 0.5 ) ## [1] 1.0 1.5 2.0 2.5 3.0 Auch sehr nützlich: rep(x = c(&quot;Nein!&quot;,&quot;Doch!&quot;), times = 3 ) ## [1] &quot;Nein!&quot; &quot;Doch!&quot; &quot;Nein!&quot; &quot;Doch!&quot; &quot;Nein!&quot; &quot;Doch!&quot; 4.1.1 Abfragen von Werten durch Subsetting von Vektoren Mit dem Operator [] können einzelne Elemente eines Vektors abgefragt werden. Hier zum Beispiel die Indexposition 2: DJ_Alter[2] ## [1] 45 Der Operator ist aber tatsächlich ein “Subset”-Operator und damit wesentlich flexibler und sehr mächtig: DJ_Name[c(1,3)] ## [1] &quot;DJ Puma&quot; &quot;Molly&quot; DJ_Name[-c(1,3)] ## [1] &quot;Cabanne&quot; &quot;Echoton&quot; &quot;cv313&quot; Der Subset-Operator ermöglicht es uns also auch eine Teilmenge des Vektors nach bestimmten Kriterien abzufragen. Hier zum Beispiel die Teilmenge derjenigen Werte, welche einen entsprechenden Index haben. Man sollte [] als einen Operator verstehen, welcher von links auf einen Vektor angewendet wird. Übergibt man [] einen logischen Vektor (passender Länge), so werden alle korrespondierenden “wahren” Elemente eines Vektors ermittelt. Dies ist tatsächlich eine der häufigsten Verwendungen von []: DJ_Name ## [1] &quot;DJ Puma&quot; &quot;Cabanne&quot; &quot;Molly&quot; &quot;Echoton&quot; &quot;cv313&quot; DJ_Vinyl ## [1] FALSE TRUE TRUE FALSE FALSE DJ_Name[DJ_Vinyl] ## [1] &quot;Cabanne&quot; &quot;Molly&quot; 4.1.2 Vektorisierte Operationen Alle atomaren Datentypen sind tatsächlich Vektoren der Länge 1 zahl &lt;- 1 p &lt;- TRUE name &lt;- &quot;Tom&quot; length(zahl) ## [1] 1 length(p) ## [1] 1 length(name) ## [1] 1 Analog agieren dann (fast) alle Operationen, welche für atomare Datentypen definiert sind als vektorisierte Operation, d.h. elementweise: x &lt;- c(1,2,3) y &lt;- c(2,1,3) x + y ## [1] 3 3 6 x + 1 ## [1] 2 3 4 log(x) ## [1] 0.0000000 0.6931472 1.0986123 DJ_Alter &gt; 21 ## [1] TRUE TRUE TRUE TRUE FALSE Der letzte Ausdruck wertet elementweise aus, ob das jeweilige Alter größer als 21 ist und bildet das Ergebnis anschließend auf einen logischen Vektor mit korrespondierender Länge ab. 4.1.3 Operationen auf Vektoren Abhängig vom Datentyp eines Vektors existieren verschiedene Funktionen, welche als Argument einen Vektor nehmen und auf ein Resultat abbilden. Operation Beschreibung length() Länge eines Vektors mean() Durchschnittswert eines num. Vektors max() Maximum eines num. Vektors any() Ist irgendein Wert eines log. Vektors wahr? mean(DJ_Alter) ## [1] 30.4 any(DJ_Vinyl) ## [1] TRUE 4.2 Matrizen Die Datenstruktur einer Matrix verallgemeinert das Konzept eines Vektors in zwei Dimensionen. Eine Matrix kann z. B. durch einen Vektor mit dem Befehl matrix() generiert werden: M &lt;- matrix(data = 1:9, nrow = 3, ncol = 3, byrow = TRUE ) M ## [,1] [,2] [,3] ## [1,] 1 2 3 ## [2,] 4 5 6 ## [3,] 7 8 9 Das Ergebnis gibt uns schon einen Hinweis darauf, wie wir die Matrix “subsetten” können. In den eckigen Klammern ist jeweils der Index vermerkt welche Zeile bzw. Spalte dargestellt wird. Die Indizierung erfolgt dann ähnlich zu Vektoren: M[1,2] ## [1] 2 Lassen wir ein Argument offen und geben zum Beispiel nur einen Zeilenindex an, evaluiert der Ausdruck entsprechend zur gesamten angegebenen Zeile. M[2, ] ## [1] 4 5 6 Analog können wir auch nur das Argument für die Spalte angeben: M[ ,1] ## [1] 1 4 7 4.2.1 Benennung von Spalten Mit der Funktion colnames() lassen sich einerseits die Spalten (columns) einer Matrix benennen/ändern, als auch abrufen. colnames(M) &lt;- c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;) M ## A B C ## [1,] 1 2 3 ## [2,] 4 5 6 ## [3,] 7 8 9 colnames(M) ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; Die Funktion rownames() macht dann gleiches für die Zeilen einer Matrix. Über die Spaltennamen können wir nun auch auf die Elemente der Matrix zugreifen: M[ ,&quot;B&quot;] ## [1] 2 5 8 4.2.2 Erzeugung von Matrizen aus Vektoren Zwei Vektoren können mit der Funktion cbind() in eine Matrix überführt werden. D &lt;- cbind(DJ_Name,DJ_Vinyl) D ## DJ_Name DJ_Vinyl ## [1,] &quot;DJ Puma&quot; &quot;FALSE&quot; ## [2,] &quot;Cabanne&quot; &quot;TRUE&quot; ## [3,] &quot;Molly&quot; &quot;TRUE&quot; ## [4,] &quot;Echoton&quot; &quot;FALSE&quot; ## [5,] &quot;cv313&quot; &quot;FALSE&quot; Analog können mit rbind() zwei Vektoren als Zeilen zu einer Matrix gebunden werden. 4.3 Listen Eine Liste ist ein “verallgemeinerter Vektor” und lässt als Elemente beliebige Werte oder Datenstrukturen zu: profil_marie &lt;- list(Name = &quot;Marie&quot;, Freunde = c(&quot;Daphne&quot;,&quot;Peter&quot;), Alter = 24 ) profil_marie ## $Name ## [1] &quot;Marie&quot; ## ## $Freunde ## [1] &quot;Daphne&quot; &quot;Peter&quot; ## ## $Alter ## [1] 24 Die Elemente können auch gleich einem Namen zugeordnet werden. 4.3.1 Indizierung von Listen Die Indizierung von Listen funktioniert etwas anders als bei den homogenen Datenstrukturen, da die Liste eigentlich nur Referenzen auf Objekte sammelt. Wenn wir die einzelnen Objekte für Operationen verwenden wollen, nutzen wir am besten den $ (Dollar) Operator. So können wir die Objekte, auf welche die Liste verweist, direkt ‘ansprechen’. profil_marie$Name ## [1] &quot;Marie&quot; profil_marie$Freunde ## [1] &quot;Daphne&quot; &quot;Peter&quot; Die Verwendung des mittlerweile altbekannten Subset-Operators ist auch möglich. Allerdings müssen wir hier die verschachtelte Struktur der Liste immer mitdenken, was es deutlich komplizierter macht. Hier ein Beispiel: profil_marie[2] ## $Freunde ## [1] &quot;Daphne&quot; &quot;Peter&quot; Mit diesem Aufruf erhalten wir einen Verweis, welcher auf einen Vektor zeigt, welcher die Zeichenketten “Daphne” und “Peter” beinhaltet. profil_marie[[2]][1] ## [1] &quot;Daphne&quot; Diese Funktion evaluiert im ersten Teil profil_marie[[2]] nun tatsächlich zu dem Vektor, auf welchen die Referenz zeigt. Auf diesen wird anschließend nun noch mal der Subset-Operator für die erste Position angewandt (Unser_Vektor[1]). So erhalten wir das erste Element des Vektors. (Was wiederum ein ein-elementiger Vektor ist.) Deutlich einfacher ist hingegen die Indizierung mithilfe des Dollar-Operators und den Namen der Objekte. Damit kommen wir deutlich lesbarer zum selben Ergebnis: profil_marie$Freunde[1] ## [1] &quot;Daphne&quot; Falls ihr noch tiefer in das Subsetting von Listen einsteigen wollt, empfiehlt sich das Kapitel “Subsetting” aus dem Buch Advanced R. 4.4 Data Frames Die für statistische Zwecke häufigste und wichtigste Datenstruktur ist die einer Datentabelle, ein sogenanntes dataframe. Diese können wir ganz einfach aus Vektoren erzeugen: df_lineup &lt;- data.frame(Name = DJ_Name, Alter = DJ_Alter ) df_lineup ## Name Alter ## 1 DJ Puma 34 ## 2 Cabanne 45 ## 3 Molly 28 ## 4 Echoton 25 ## 5 cv313 20 4.4.1 Indizierung von Datentabellen Analog zu Matrizen: df_lineup[3, ] ## Name Alter ## 3 Molly 28 df_lineup[ ,2] ## [1] 34 45 28 25 20 Analog zu Listen können wir die Spalten auch über ihren Namen anwählen. df_lineup$Name ## [1] &quot;DJ Puma&quot; &quot;Cabanne&quot; &quot;Molly&quot; &quot;Echoton&quot; &quot;cv313&quot; 4.4.2 Aufname weiterer Variablen/Spalten Analog zu Matrizen können wir mit der Funktion cbind() Vektoren als Spalten unseres Data Frames aufnehmen. df_lineup &lt;- cbind(df_lineup,DJ_Vinyl) df_lineup ## Name Alter DJ_Vinyl ## 1 DJ Puma 34 FALSE ## 2 Cabanne 45 TRUE ## 3 Molly 28 TRUE ## 4 Echoton 25 FALSE ## 5 cv313 20 FALSE Alternativ können wir eine Spalte anwählen, welche es noch nicht gibt und anschließend diese an einen Vektor binden. Zur Illustration brauchen wir noch einen weiteren Vektor: DJ_Geburtsjahr &lt;- 2022 - DJ_Alter df_lineup$Geburtsjahr &lt;- DJ_Geburtsjahr df_lineup ## Name Alter DJ_Vinyl Geburtsjahr ## 1 DJ Puma 34 FALSE 1988 ## 2 Cabanne 45 TRUE 1977 ## 3 Molly 28 TRUE 1994 ## 4 Echoton 25 FALSE 1997 ## 5 cv313 20 FALSE 2002 4.4.3 Operationen auf Datentabellen Die Objekt, welche in einer Datentabelle gespeichert sind, können wir, wie alle anderen Objekte auch, in Funktionsaufrufen weiter verwenden. mean(df_lineup$Alter) ## [1] 30.4 4.5 Prüfe dich selbst Du solltest die vier grundlegenden strukturierten Datentypen nennen und unterscheiden können. Du solltest wissen, auf welche Weisen du auf die Elemente der unterschiedlichen strukturierten Datentypen zugreifen kannst. Du solltest verstanden haben, welche Möglichkeiten es gibt, verschiedene Teilmengen eines strukturierten Datentyps abzufragen. "],["funktionen.html", "Kapitel 5 Funktionen", " Kapitel 5 Funktionen "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
